// Cyclical figurate numbers
//
// Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers
// are all figurate (polygonal) numbers and are generated by the following
// formulae:
// Triangle         P3,n=n(n+1)/2       1, 3, 6, 10, 15, ...
// Square           P4,n=n²             1, 4, 9, 16, 25, ...
// Pentagonal       P5,n=n(3n−1)/2      1, 5, 12, 22, 35, ...
// Hexagonal        P6,n=n(2n−1)        1, 6, 15, 28, 45, ...
// Heptagonal       P7,n=n(5n−3)/2      1, 7, 18, 34, 55, ...
// Octagonal        P8,n=n(3n−2)        1, 8, 21, 40, 65, ...
//
// The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three
// interesting properties.
//
// 1.  The set is cyclic, in that the last two digits of each number is the
//     first two digits of the next number (including the last number with the
//     first).
// 2.  Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and
//     pentagonal (P5,44=2882), is represented by a different number in the set.
// 3.  This is the only set of 4-digit numbers with this property.
//
// Find the sum of the only ordered set of six cyclic 4-digit numbers for
// which each polygonal type: triangle, square, pentagonal, hexagonal,
// heptagonal, and octagonal, is represented by a different number in the set.


#![feature(test)]
extern crate test;

extern crate itertools;
use itertools::Itertools;

use std::collections::HashMap;

const TAG: usize = (1 << 6) - 1;

#[derive(Debug, Clone, Copy)]
struct Num {
    n: usize,   // the number
    f: u8,      // 2-digits front part
    b: u8,      // 2-digits back part
    id: u8,     // id that represents polygonal family
}

impl Num {
    fn new(n: usize, i: u8) -> Self {
        Num { n: n, f: (n / 100) as u8, b: (n % 100) as u8, id: i }
    }
}

fn gen(id: u8, form: &Fn(usize) -> usize) -> Vec<Num> {
    (1..).map(form)
         .skip_while(|&i| i < 1_000).take_while(|&i| i < 10_000)
         .map(|i| Num::new(i, id)).collect()
}

pub fn solve() -> (Vec<usize>, usize) {
    // list all numbers of each polygonal type, tag from 1 to 6
    let mut ls: Vec<Num> = Vec::new();
    ls.append(&mut gen(0, &|n| n * (n+1) / 2));
    ls.append(&mut gen(1, &|n| n * n));
    ls.append(&mut gen(2, &|n| n * (3*n-1) / 2));
    ls.append(&mut gen(3, &|n| n * (2*n+1)));
    ls.append(&mut gen(4, &|n| n * (5*n-3) / 2));
    ls.append(&mut gen(5, &|n| n * (3*n-2)));

    // map of front values and back values
    ls.sort_by(|&x, &y| x.f.cmp(&y.f));
    let fronts = ls.iter().cloned().group_by(|&n| n.f).collect::<HashMap<_,_>>();
    ls.sort_by(|&x, &y| x.b.cmp(&y.b));
    let backs  = ls.iter().cloned().group_by(|&n| n.b).collect::<HashMap<_,_>>();

    // list all the triplets that follow each other
    let mut triplets = Vec::new();
    for n in &ls {
        if let Some(vf) = fronts.get(&n.b) {
            if let Some(vb) = backs.get(&n.f) {
                for nf in vf {
                    for nb in vb {
                        // different families
                        if n.id == nf.id || n.id == nb.id || nf.id == nb.id {
                            continue;
                        }

                        // different values
                        if n.n == nf.n || n.n == nb.n || nf.n == nb.n {
                            continue;
                        }

                        let t = (1<<nb.id) + (1<<n.id) + (1<<nf.id);
                        triplets.push((t, [nb, n, nf]));
                    }
                }
            }
        }
    }

    // try to find 2 triplets that make a complete circle
    for &(t1, v1) in &triplets {
        for &(t2, v2) in &triplets {
            // cycle and different families
            if v1[2].b != v2[0].f || v1[0].f != v2[2].b || t1 + t2 != TAG {
                continue;
            }
            // different values
            if (0..2).cartesian_product(0..2).any(|(i,j)| v1[i].n == v2[j].n) {
                continue
            }

            let nums = vec![v1[0].n, v1[1].n, v1[2].n, v2[0].n, v2[1].n, v2[2].n];
            let sum = nums.iter().fold(0, |a, c| a + c);
            return (nums, sum);
        }
    }

    (Vec::new(), 0)
}

fn main() {
    let s = solve();
    println!("numbers: {:?}, sum: {}", s.0, s.1);
}

#[cfg(test)]
mod tests {
    use super::*;
    use test::{Bencher, black_box};

    #[test]
    fn test_61() {
        let s = solve();
        assert_eq!(28684, s.1);
    }

    #[bench]
    fn bench_61(b: &mut Bencher) {
        b.iter(|| black_box(solve()));
    }
}

